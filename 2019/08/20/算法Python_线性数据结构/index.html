<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="lixh's blog"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>算法Python_线性数据结构 | lixh's blog</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法Python_线性数据结构</h1><a id="logo" href="/.">lixh's blog</a><p class="description">Learn and Share</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">算法Python_线性数据结构</h1><div class="post-meta"><a href="/2019/08/20/算法Python_线性数据结构/#comments" class="comment-count"></a><p><span class="date">Aug 20, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>使用python实现数据结构中的线性数据结构。</p>
<a id="more"></a>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><hr>
<ul>
<li>理解抽象数据类型，包括堆栈、队列、双端队列和列表；</li>
<li>使用 Python 实现抽象数据类型；</li>
<li>了解基本线性数据结构的实现性能；</li>
<li>了解前缀、中缀和后缀表达式格式，并使用堆栈进行实现和转换；</li>
<li>使用队列进行基础时序模拟；</li>
<li>使用 Python 实现链表结构，并进行性能比较。</li>
</ul>
<h1 id="什么是线性结构"><a href="#什么是线性结构" class="headerlink" title="什么是线性结构"></a>什么是线性结构</h1><hr>
<ul>
<li>线性结构具有两个端点，可以称为 <code>左端</code> 和 <code>右端</code>，或者 <code>顶部</code> 和 <code>底部</code>。</li>
<li>线性结构之间的区别主要在于添加和删除数据元素的方式。</li>
</ul>
<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><hr>
<h2 id="堆栈介绍"><a href="#堆栈介绍" class="headerlink" title="堆栈介绍"></a>堆栈介绍</h2><hr>
<p>堆栈是数据元素的有序集合，其中元素的添加和删除总是在同一端进行。这一端被称为 <code>顶端</code>。最后添加的元素最先被删除，该原则称为 <code>LIFO(last-in first-out)</code>。堆栈中的元素顺序和时间长度有关，较新的元素靠近顶端，较旧的元素靠近底端。</p>
<p><img src="/images/primitive.png" alt="图1 堆栈结构"></p>
<p>由于堆栈后进先出的特性，非常适用于翻转元素顺序的应用场景。移除的顺序和插入的顺序相反。图2显示了创建 Python 堆栈对象时的元素顺序和移出时的元素顺序。</p>
<p><img src="/images/simplereversal.png" alt="图2 堆栈的翻转特性"></p>
<p>应用场景：</p>
<ul>
<li>浏览器的后退功能。将访问过的 URLs 存储到一个堆栈中，当前访问的在最顶部。</li>
</ul>
<h2 id="堆栈抽象数据类型"><a href="#堆栈抽象数据类型" class="headerlink" title="堆栈抽象数据类型"></a>堆栈抽象数据类型</h2><hr>
<p>堆栈抽象数据类型由以下结构和操作定义。</p>
<ul>
<li>结构：堆栈是一个有序集合，数据元素在顶端进行添加和删除。</li>
<li>操作：<ul>
<li><code>Stack()</code>：创建一个堆栈，返回为空堆栈。</li>
<li><code>push(item)</code>：在堆栈顶端添加一个元素。无返回。</li>
<li><code>pop()</code>：移出并返回堆栈的顶端元素。</li>
<li><code>peek()</code>：返回堆栈的顶端元素但并不删除。</li>
<li><code>isEmpty()</code>：判空。返回布尔值。</li>
<li><code>size()</code>：返回堆栈的元素个数。整型。</li>
</ul>
</li>
</ul>
<h2 id="使用-Python-实现堆栈"><a href="#使用-Python-实现堆栈" class="headerlink" title="使用 Python 实现堆栈"></a>使用 Python 实现堆栈</h2><hr>
<p>在 Python 中，就像在任何面向对象的编程语言中一样，我们使用 <code>类</code> 来实现抽象数据类型，使用方法实现其操作。堆栈作为一个元素集合，使用 Python 中强大的 <code>list</code> 进行构造。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Python list 构造堆栈结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.items = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    self.items.append(item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items[len(self.items)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure>

<h2 id="应用：括号匹配（简单）"><a href="#应用：括号匹配（简单）" class="headerlink" title="应用：括号匹配（简单）"></a>应用：括号匹配（简单）</h2><hr>
<ul>
<li>功能描述：输入一串括号，判断这些括号是否匹配。</li>
<li>分析：从左到右读取括号串，右括号总是匹配最近一次的左括号，而最先读取的左括号可能需要等到后面。右括号匹配左括号的顺序刚好和左括号的存储顺序相反，故使用堆栈解决该问题。</li>
<li>实现：<ul>
<li>创建一个空堆栈，碰到左括号将其存入；</li>
<li>碰到右括号，取出堆栈的顶端元素进行匹配。如果匹配，则删除顶端元素，否则整个括号串不平衡。</li>
<li>字符串读取结束后，判断堆栈是否为空。不为空则括号串不平衡。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(symbolString)</span>:</span></span><br><span class="line">  s = Stack()</span><br><span class="line">  balanced = <span class="literal">True</span></span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> index &lt; len(symbolString) <span class="keyword">and</span> balanced:</span><br><span class="line">    symbol = symbolString[i]</span><br><span class="line">    <span class="keyword">if</span> symbol == <span class="string">"("</span>:</span><br><span class="line">      s.push(symbol)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">        balanced = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        s.pop()</span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">print(parCheckr(<span class="string">"((()))"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="应用：括号匹配（复杂）"><a href="#应用：括号匹配（复杂）" class="headerlink" title="应用：括号匹配（复杂）"></a>应用：括号匹配（复杂）</h2><hr>
<p>上一个应用中只涉及了小括号的匹配，而实际情况中，括号不光需要匹配左右对应，同时也要匹配不同的括号类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(symbolString)</span>:</span></span><br><span class="line">  s = Stack()</span><br><span class="line">  balanced = <span class="literal">True</span></span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> index &lt; len(symbolString) <span class="keyword">and</span> balanced:</span><br><span class="line">    symbol = symbolString[i]</span><br><span class="line">    <span class="keyword">if</span> symbol <span class="keyword">in</span> <span class="string">"([&#123;"</span>:</span><br><span class="line">      s.push(symbol)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">        balanced = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        top = s.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matches(top, symbol):</span><br><span class="line">          balanced = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matches</span><span class="params">(open, close)</span>:</span></span><br><span class="line">  opens = <span class="string">"([&#123;"</span></span><br><span class="line">  closes = <span class="string">")]&#125;"</span></span><br><span class="line">  <span class="keyword">return</span> opens.index(open) == closes.index(close)</span><br><span class="line"></span><br><span class="line">print(parChecker(<span class="string">'&#123;(&#123;([][])&#125;())&#125;'</span>))</span><br><span class="line">print(parChecker(<span class="string">'[&#123;()]'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="应用：进制转换"><a href="#应用：进制转换" class="headerlink" title="应用：进制转换"></a>应用：进制转换</h2><hr>
<p>使用“被2除”算法可以将十进制数转换为二进制数。“被2除”算法假定我们以大于0的整数开始，不断迭代将十进制数除以2，并保存其余数。最后将余数序列逆序极为转换后的二进制数。图3显示了该算法的过程。</p>
<p><img src="/images/dectobin.png" alt="图3 二进制转换"></p>
<p>下面使用 Python 实现该算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devideBy2</span><span class="params">(decNumber)</span>:</span></span><br><span class="line">  remstack = Stack()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> decNumber &gt; <span class="number">0</span>:</span><br><span class="line">    rem = decNumber % <span class="number">2</span></span><br><span class="line">    remstack.push(rem)</span><br><span class="line">    decNumber = decNumber // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  binString = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</span><br><span class="line">    binString = binString + str(remstack.pop())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binString</span><br><span class="line"></span><br><span class="line">print(devideBy2(<span class="number">42</span>))</span><br></pre></td></tr></table></figure>

<p>上面的二进制转换可以很容易扩展到任意进制转换。在计算机科学中，通常使用不同的进制编码，常用的有八进制和十六进制。<br>可以修改 <code>devideBy2</code> 算法，使其不仅接收十进制数，还能接收进制转换基数。下面算法实现了十进制数到2-16进制之间的转换。同时，当基数大于10后，已经不能简单地使用0-9来表示余数了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseConverter</span><span class="params">(decNumber, base)</span>:</span></span><br><span class="line">  digits = <span class="string">"0123456789ABCDEF"</span></span><br><span class="line"></span><br><span class="line">  remstack = Stack()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> decNumber &gt; <span class="number">0</span>:</span><br><span class="line">    rem = decNumber % base</span><br><span class="line">    remstack.push(rem)</span><br><span class="line">    decNumber = decNumber // base</span><br><span class="line"></span><br><span class="line">  newString = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</span><br><span class="line">    newString = newString + digits[remstack.pop()]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newString</span><br><span class="line"></span><br><span class="line">print(baseConverter(<span class="number">25</span>, <span class="number">2</span>))</span><br><span class="line">print(baseConverter(<span class="number">25</span>, <span class="number">16</span>))</span><br></pre></td></tr></table></figure>

<h2 id="应用：前缀、中缀、后缀表达式"><a href="#应用：前缀、中缀、后缀表达式" class="headerlink" title="应用：前缀、中缀、后缀表达式"></a>应用：前缀、中缀、后缀表达式</h2><hr>
<p>对于平常使用的表达式，如 $A+B<em>C$，操作符在两个操作数之间，则称为 <code>中缀表达式</code>。如果将操作符放在需要操作的两个操作数之间，如 $+A*BC$，则为 <code>前缀表达式</code>。如果将操作符放在需要操作的两个操作数之后，如 $ABC</em>+$，则为 <code>后缀表达式</code>。在计算机操作中，一般将中缀表达式转换为前缀或后缀表达式，原因：</p>
<ul>
<li>中缀表达式需要括号和操作符优先级定义计算顺序，对计算机较为复杂；</li>
<li>前缀或后缀表达式中，操作符的位置定义了操作顺序，不需要括号和操作符的优先级，计算机实现简单。</li>
</ul>
<h3 id="将中缀表达式转换为前缀或后缀表达式"><a href="#将中缀表达式转换为前缀或后缀表达式" class="headerlink" title="将中缀表达式转换为前缀或后缀表达式"></a>将中缀表达式转换为前缀或后缀表达式</h3><p>对于中缀表达式，我们可以通过添加括号构造完全括号表达式，即只使用括号来定义操作顺序。对于完全括号表达式，我们只需要将操作符移动到右括号处，同时删除匹配的左括号，即可实现中缀表达式到后缀表达式的转换。过程如图4所示。</p>
<p><img src="/images/moveright.png" alt="图4 向右移动运算符"></p>
<p>同理，向左移动运算符，同时删除相匹配的右括号，即可得到前缀表达式。</p>
<h3 id="通用中缀到后缀转换"><a href="#通用中缀到后缀转换" class="headerlink" title="通用中缀到后缀转换"></a>通用中缀到后缀转换</h3><p>对于表达式转换，操作数的位置不会发生变化，只有操作符的位置进行了移动。在后缀表达式中，原有操作符的顺序可能会根据操作优先级进行翻转。所以使用堆栈来存储操作符。<br>对于有括号的表达式，遇到左括号时将其存储，在遇到右括号后，将存储的操作符取出。<br>假定中缀表达式是由空格分隔的一串字符串。运算符有+、-、* 和 /，也包括左右小括号。操作数由单字符A、B、C等进行标记。将中缀转换为后缀的步骤如下：</p>
<ul>
<li>创建一个空的堆栈 <code>opstack</code> 保存操作符，一个空的列表保存结果。</li>
<li>使用字符串方法 <code>split</code> 将输入字符串转换为列表。</li>
<li>从左到右扫描整个列表：<ul>
<li>如果是操作数，将其存储到输出列表的末尾；</li>
<li>如果是左括号，存储到 <code>opstack</code> 中；</li>
<li>如果是右括号，从 <code>opstack</code> 中取元素，直到相匹配的左括号被删除为止。把操作符依次存储到结果列表末尾；</li>
<li>如果是操作符，将其存储到 <code>opstack</code> 中。但是，首先需要移出任何大于或等于该操作符优先级的操作符，并将其存储到结果列表中；</li>
</ul>
</li>
<li>但输入列表扫描完毕，检查 <code>opstack</code>。任何在堆栈中的操作符都取出并添加到结果列表中。</li>
</ul>
<p>图5显示了表达式 <em>AB+CD</em> 的转换过程。</p>
<p><img src="/images/intopost.png" alt="图5 转为后缀表达式"></p>
<p>下面使用 Python 实现该过程。同时，使用字典 <code>prec</code> 存储操作符的优先级。左括号有最小优先级，这样所有的操作符都比左括号优先级高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></span><br><span class="line">  prec = &#123;&#125;</span><br><span class="line">  prec[<span class="string">"*"</span>] = <span class="number">3</span></span><br><span class="line">  prec[<span class="string">"/"</span>] = <span class="number">3</span></span><br><span class="line">  prec[<span class="string">"+"</span>] = <span class="number">2</span></span><br><span class="line">  prec[<span class="string">"-"</span>] = <span class="number">2</span></span><br><span class="line">  prec[<span class="string">"("</span>] = <span class="number">1</span></span><br><span class="line">  opStack = Stack()</span><br><span class="line">  postfixList = []</span><br><span class="line">  tokenList = infixexpr.split()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">    <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</span><br><span class="line">      postfixList.append(token)</span><br><span class="line">    <span class="keyword">elif</span> token = <span class="string">"("</span>:</span><br><span class="line">      opStack.push(token)</span><br><span class="line">    <span class="keyword">elif</span> token = <span class="string">")"</span>:</span><br><span class="line">      topToken = opStack.pop()</span><br><span class="line">      <span class="keyword">while</span> topToken != <span class="string">"("</span>:</span><br><span class="line">        postfixList.append(topToken)</span><br><span class="line">        topToken = opStack.pop()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">        postfixList.append(opStack.pop())</span><br><span class="line">      opStack.push(token)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">    postfixList.append(opStack.pop())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">" "</span>.join(postfixList)</span><br><span class="line"></span><br><span class="line">print(infixToPostfix(<span class="string">"A * B + C * D"</span>))</span><br><span class="line">print(infixToPostfix(<span class="string">"( A + B ) * C - ( D - E ) * ( F + G )"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h3><p>在计算后缀表达式时，也需要使用到堆栈。但这次堆栈中应该存储操作数。每次遇到操作符，都应该从堆栈中取出两个最近的操作数进行计算，并将结果继续存储到堆栈中。</p>
<p><img src="/images/evalpostfix1.png" alt="图6 计算后缀表达式4 5 6 * +"></p>
<p>假设后缀表达式是由空格分隔的字符串。运算符是*，/，+和 - 并且操作数假定为整数。输出是整数结果。计算后缀表达式的步骤如下：</p>
<ol>
<li>创建一个空栈 <code>operandStack</code> 来存储操作数；</li>
<li>使用 <code>split</code> 把输入字符串转换为列表；</li>
<li>从左到右扫描整个列表：<ul>
<li>如果是操作数，将其转换为整型并存储到堆栈 <code>operandStack</code> 中；</li>
<li>如果是操作符，则需要取出两个操作数。第一次取出的作为第二个操作数，第二次取出的作为第一个操作数。计算后将结果存储到堆栈 <code>operandStack</code> 中；</li>
</ul>
</li>
<li>扫描完成后，取出堆栈中的值作为结果返回。</li>
</ol>
<p>下面使用 Python 实现该算法。定义一个函数 <code>doMath</code>，接收两个操作数和一个操作符，进行相应的运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postfixEval</span><span class="params">(postfixExpr)</span>:</span></span><br><span class="line">  operandStack = Stack()</span><br><span class="line">  tokenList = postfixExpr.split()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">    <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</span><br><span class="line">      operandStack.push(int(token))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      operand2 = operandStack.pop()</span><br><span class="line">      operand1 = operandStack.pop()</span><br><span class="line">      result = doMath(token, operand1, operand2)</span><br><span class="line">      operandStack.push(result)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> operandStack.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doMath</span><span class="params">(op, op1, op2)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> op == <span class="string">"*"</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 * op2</span><br><span class="line">  <span class="keyword">elif</span> op == <span class="string">"/"</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 / op2</span><br><span class="line">  <span class="keyword">elif</span> op == <span class="string">"+"</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 + op2</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 - op2</span><br><span class="line"></span><br><span class="line">print(postfixEval(<span class="string">'7 8 + 3 2 + /'</span>))</span><br></pre></td></tr></table></figure>

<p>上述的算法都是假定输入表达式没有错误的。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><hr>
</div><div class="post-copyright"><blockquote><p>原文作者: lixh</p><p>原文链接: <a href="http://yoursite.com/2019/08/20/算法Python_线性数据结构/">http://yoursite.com/2019/08/20/算法Python_线性数据结构/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/20/hello-world/" class="next">Hello World</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: '797d74e1958a846713d9',
  clientSecret: '2bab30fb152aaf3d7f61a916fbe04135e950f57f',
  repo: 'Mr-lixh.github.io',
  owner: 'Mr-lixh',
  admin: ['Mr-lixh'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#目标"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是线性结构"><span class="toc-text">什么是线性结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆栈"><span class="toc-text">堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆栈介绍"><span class="toc-text">堆栈介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆栈抽象数据类型"><span class="toc-text">堆栈抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Python-实现堆栈"><span class="toc-text">使用 Python 实现堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：括号匹配（简单）"><span class="toc-text">应用：括号匹配（简单）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：括号匹配（复杂）"><span class="toc-text">应用：括号匹配（复杂）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：进制转换"><span class="toc-text">应用：进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：前缀、中缀、后缀表达式"><span class="toc-text">应用：前缀、中缀、后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将中缀表达式转换为前缀或后缀表达式"><span class="toc-text">将中缀表达式转换为前缀或后缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用中缀到后缀转换"><span class="toc-text">通用中缀到后缀转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后缀表达式计算"><span class="toc-text">后缀表达式计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/算法Python_线性数据结构/">算法Python_线性数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Mr-lixh" title="github" target="_blank">github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">lixh.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?13549e9998ed36aa1cfcbd1ebe61afe0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>