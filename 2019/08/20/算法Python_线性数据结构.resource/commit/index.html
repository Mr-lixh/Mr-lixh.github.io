<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="lixh's blog"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title> | lixh's blog</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">lixh's blog</h1><a id="logo" href="/.">lixh's blog</a><p class="description">Learn and Share</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-meta"><a href="/2019/08/20/算法Python_线性数据结构.resource/commit/#comments" class="comment-count"></a><p><span class="date">Aug 20, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content">{"compress":true,"commitItems":[["593dcb32-780b-436d-9b43-001a79bcb2b2",1566309103010,"---\ntitle: 算法Python：线性数据结构\ndate: 2019T17:55:32.000Z\ntags: 算法\n---\n使用python实现数据结构中的线性数据结构。\n<a id="more"></a>\n# 目标\n\n---\n\n* 理解抽象数据类型，包括堆栈、队列、双端队列和列表；\n* 使用 Python 实现抽象数据类型；\n* 了解基本线性数据结构的实现性能；\n* 了解前缀、中缀和后缀表达式格式，并使用堆栈进行实现和转换；\n* 使用队列进行基础时序模拟；\n* 使用 Python 实现链表结构，并进行性能比较。\n\n# 什么是线性结构\n\n---\n\n* 线性结构具有两个端点，可以称为 `左端` 和 `右端`，或者 `顶部` 和 `底部`。\n* 线性结构之间的区别主要在于添加和删除数据元素的方式。\n\n# 堆栈\n\n---\n\n## 堆栈介绍\n\n---\n\n堆栈是数据元素的有序集合，其中元素的添加和删除总是在同一端进行。这一端被称为 `顶端`。最后添加的元素最先被删除，该原则称为 `LIFO(last-in first-out)`。堆栈中的元素顺序和时间长度有关，较新的元素靠近顶端，较旧的元素靠近底端。\n\n![图1 堆栈结构](/images/primitive.png)\n\n由于堆栈后进先出的特性，非常适用于翻转元素顺序的应用场景。移除的顺序和插入的顺序相反。图2显示了创建 Python 堆栈对象时的元素顺序和移出时的元素顺序。\n\n![图2 堆栈的翻转特性](/images/simplereversal.png)\n\n\n应用场景：\n\n* 浏览器的后退功能。将访问过的 URLs 存储到一个堆栈中，当前访问的在最顶部。\n\n## 堆栈抽象数据类型\n\n---\n\n堆栈抽象数据类型由以下结构和操作定义。\n\n* 结构：堆栈是一个有序集合，数据元素在顶端进行添加和删除。\n* 操作：\n  * `Stack()`：创建一个堆栈，返回为空堆栈。\n  * `push(item)`：在堆栈顶端添加一个元素。无返回。\n  * `pop()`：移出并返回堆栈的顶端元素。\n  * `peek()`：返回堆栈的顶端元素但并不删除。\n  * `isEmpty()`：判空。返回布尔值。\n  * `size()`：返回堆栈的元素个数。整型。\n\n## 使用 Python 实现堆栈\n\n---\n\n在 Python 中，就像在任何面向对象的编程语言中一样，我们使用 `类` 来实现抽象数据类型，使用方法实现其操作。堆栈作为一个元素集合，使用 Python 中强大的 `list` 进行构造。\n\n```python\n# 使用 Python list 构造堆栈结构\nclass Stack():\n  def __init__(self):\n    self.items = []\n\n  def isEmpty(self):\n    return self.items == []\n\n  def push(self, item):\n    self.items.append(item)\n\n  def pop(self):\n    return self.items.pop()\n\n  def peek(self):\n    return self.items[len(self.items)-1]\n\n  def size(self):\n    return len(self.items)\n```\n\n## 应用：括号匹配（简单）\n\n---\n\n* 功能描述：输入一串括号，判断这些括号是否匹配。\n* 分析：从左到右读取括号串，右括号总是匹配最近一次的左括号，而最先读取的左括号可能需要等到后面。右括号匹配左括号的顺序刚好和左括号的存储顺序相反，故使用堆栈解决该问题。\n* 实现：\n  * 创建一个空堆栈，碰到左括号将其存入；\n  * 碰到右括号，取出堆栈的顶端元素进行匹配。如果匹配，则删除顶端元素，否则整个括号串不平衡。\n  * 字符串读取结束后，判断堆栈是否为空。不为空则括号串不平衡。\n\n```python\ndef parChecker(symbolString):\n  s = Stack()\n  balanced = True\n  index = 0\n  while index < len(symbolString) and balanced:\n    symbol = symbolString[i]\n    if symbol == \"(\":\n      s.push(symbol)\n    else:\n      if s.isEmpty():\n        balanced = False\n      else:\n        s.pop()\n\n    index += 1\n    \n  if balanced and s.isEmpty():\n    return True\n  else:\n    return False\n\nprint(parCheckr(\"((()))\"))\n```\n\n## 应用：括号匹配（复杂）\n\n---\n\n上一个应用中只涉及了小括号的匹配，而实际情况中，括号不光需要匹配左右对应，同时也要匹配不同的括号类型。\n\n```python\ndef parChecker(symbolString):\n  s = Stack()\n  balanced = True\n  index = 0\n  while index < len(symbolString) and balanced:\n    symbol = symbolString[i]\n    if symbol in \"([{\":\n      s.push(symbol)\n    else:\n      if s.isEmpty():\n        balanced = False\n      else:\n        top = s.pop()\n        if not matches(top, symbol):\n          balanced = False\n\n    index += 1\n  if balanced and s.isEmpty():\n    return True\n  else:\n    return False\n\ndef matches(open, close):\n  opens = \"([{\"\n  closes = \")]}\"\n  return opens.index(open) == closes.index(close)\n\nprint(parChecker('{({([][])}())}'))\nprint(parChecker('[{()]'))\n```\n\n## 应用：进制转换\n\n---\n\n使用“被2除”算法可以将十进制数转换为二进制数。“被2除”算法假定我们以大于0的整数开始，不断迭代将十进制数除以2，并保存其余数。最后将余数序列逆序极为转换后的二进制数。图3显示了该算法的过程。\n\n![图3 二进制转换](/images/dectobin.png)\n\n下面使用 Python 实现该算法。\n\n```python\ndef devideBy2(decNumber):\n  remstack = Stack()\n\n  while decNumber > 0:\n    rem = decNumber % 2\n    remstack.push(rem)\n    decNumber = decNumber // 2\n\n  binString = \"\"\n  while not remstack.isEmpty():\n    binString = binString + str(remstack.pop())\n\n  return binString\n\nprint(devideBy2(42))\n```\n\n上面的二进制转换可以很容易扩展到任意进制转换。在计算机科学中，通常使用不同的进制编码，常用的有八进制和十六进制。\n可以修改 `devideBy2` 算法，使其不仅接收十进制数，还能接收进制转换基数。下面算法实现了十进制数到2-16进制之间的转换。同时，当基数大于10后，已经不能简单地使用0-9来表示余数了。\n\n```python\ndef baseConverter(decNumber, base):\n  digits = \"0123456789ABCDEF\"\n\n  remstack = Stack()\n\n  while decNumber > 0:\n    rem = decNumber % base\n    remstack.push(rem)\n    decNumber = decNumber // base\n\n  newString = \"\"\n  while not remstack.isEmpty():\n    newString = newString + digits[remstack.pop()]\n\n  return newString\n\nprint(baseConverter(25, 2))\nprint(baseConverter(25, 16))\n```\n\n## 应用：前缀、中缀、后缀表达式\n\n---\n\n对于平常使用的表达式，如 $A+B*C$，操作符在两个操作数之间，则称为 `中缀表达式`。如果将操作符放在需要操作的两个操作数之间，如 $+A*BC$，则为 `前缀表达式`。如果将操作符放在需要操作的两个操作数之后，如 $ABC*+$，则为 `后缀表达式`。在计算机操作中，一般将中缀表达式转换为前缀或后缀表达式，原因：\n\n* 中缀表达式需要括号和操作符优先级定义计算顺序，对计算机较为复杂；\n* 前缀或后缀表达式中，操作符的位置定义了操作顺序，不需要括号和操作符的优先级，计算机实现简单。\n\n### 将中缀表达式转换为前缀或后缀表达式\n\n对于中缀表达式，我们可以通过添加括号构造完全括号表达式，即只使用括号来定义操作顺序。对于完全括号表达式，我们只需要将操作符移动到右括号处，同时删除匹配的左括号，即可实现中缀表达式到后缀表达式的转换。过程如图4所示。\n\n![图4 向右移动运算符](/images/moveright.png)\n\n同理，向左移动运算符，同时删除相匹配的右括号，即可得到前缀表达式。\n\n### 通用中缀到后缀转换\n\n对于表达式转换，操作数的位置不会发生变化，只有操作符的位置进行了移动。在后缀表达式中，原有操作符的顺序可能会根据操作优先级进行翻转。所以使用堆栈来存储操作符。\n对于有括号的表达式，遇到左括号时将其存储，在遇到右括号后，将存储的操作符取出。\n假定中缀表达式是由空格分隔的一串字符串。运算符有+、-、* 和 /，也包括左右小括号。操作数由单字符A、B、C等进行标记。将中缀转换为后缀的步骤如下：\n\n* 创建一个空的堆栈 `opstack` 保存操作符，一个空的列表保存结果。\n* 使用字符串方法 `split` 将输入字符串转换为列表。\n* 从左到右扫描整个列表：\n  * 如果是操作数，将其存储到输出列表的末尾；\n  * 如果是左括号，存储到 `opstack` 中；\n  * 如果是右括号，从 `opstack` 中取元素，直到相匹配的左括号被删除为止。把操作符依次存储到结果列表末尾；\n  * 如果是操作符，将其存储到 `opstack` 中。但是，首先需要移出任何大于或等于该操作符优先级的操作符，并将其存储到结果列表中；\n* 但输入列表扫描完毕，检查 `opstack`。任何在堆栈中的操作符都取出并添加到结果列表中。\n\n图5显示了表达式 _AB+CD_ 的转换过程。\n\n![图5 转为后缀表达式](/images/intopost.png)\n\n下面使用 Python 实现该过程。同时，使用字典 `prec` 存储操作符的优先级。左括号有最小优先级，这样所有的操作符都比左括号优先级高。\n\n```python\ndef infixToPostfix(infixexpr):\n  prec = {}\n  prec[\"*\"] = 3\n  prec[\"/\"] = 3\n  prec[\"+\"] = 2\n  prec[\"-\"] = 2\n  prec[\"(\"] = 1\n  opStack = Stack()\n  postfixList = []\n  tokenList = infixexpr.split()\n\n  for token in tokenList:\n    if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\":\n      postfixList.append(token)\n    elif token = \"(\":\n      opStack.push(token)\n    elif token = \")\":\n      topToken = opStack.pop()\n      while topToken != \"(\":\n        postfixList.append(topToken)\n        topToken = opStack.pop()\n    else:\n      while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]):\n        postfixList.append(opStack.pop())\n      opStack.push(token)\n\n  while not opStack.isEmpty():\n    postfixList.append(opStack.pop())\n  return \" \".join(postfixList)\n\nprint(infixToPostfix(\"A * B + C * D\"))\nprint(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\"))\n```\n\n### 后缀表达式计算\n\n在计算后缀表达式时，也需要使用到堆栈。但这次堆栈中应该存储操作数。每次遇到操作符，都应该从堆栈中取出两个最近的操作数进行计算，并将结果继续存储到堆栈中。\n\n![图6 计算后缀表达式4 5 6 * +](/images/evalpostfix1.png)\n\n假设后缀表达式是由空格分隔的字符串。运算符是*，/，+和 - 并且操作数假定为整数。输出是整数结果。计算后缀表达式的步骤如下：\n\n1. 创建一个空栈 `operandStack` 来存储操作数；\n2. 使用 `split` 把输入字符串转换为列表；\n3. 从左到右扫描整个列表：\n    * 如果是操作数，将其转换为整型并存储到堆栈 `operandStack` 中；\n    * 如果是操作符，则需要取出两个操作数。第一次取出的作为第二个操作数，第二次取出的作为第一个操作数。计算后将结果存储到堆栈 `operandStack` 中；\n4. 扫描完成后，取出堆栈中的值作为结果返回。\n\n下面使用 Python 实现该算法。定义一个函数 `doMath`，接收两个操作数和一个操作符，进行相应的运算。\n\n```python\ndef postfixEval(postfixExpr):\n  operandStack = Stack()\n  tokenList = postfixExpr.split()\n\n  for token in tokenList:\n    if token in \"0123456789\":\n      operandStack.push(int(token))\n    else:\n      operand2 = operandStack.pop()\n      operand1 = operandStack.pop()\n      result = doMath(token, operand1, operand2)\n      operandStack.push(result)\n\n  return operandStack.pop()\n\ndef doMath(op, op1, op2):\n  if op == \"*\":\n    return op1 * op2\n  elif op == \"/\":\n    return op1 / op2\n  elif op == \"+\":\n    return op1 + op2\n  else:\n    return op1 - op2\n\nprint(postfixEval('7 8 + 3 2 + /'))\n```\n\n上述的算法都是假定输入表达式没有错误的。\n\n# 队列\n\n---\n\n\n",[[1566309100669,["a6012@DESKTOP-FSS1ODK",[[-1,19,"：线"]],[20,20],[19,19]]]],null,"a6012@DESKTOP-FSS1ODK"],["5e1ccca1-cf32-459b-b7aa-e6ce9ea49bbe",1566309120803,"---\ntitle: 算法Python性数据结构\ndate: 2019T17:55:32.000Z\ntags: 算法\n---\n使用python实现数据结构中的线性数据结构。\n<!-- more -->\n# 目标\n\n---\n\n* 理解抽象数据类型，包括堆栈、队列、双端队列和列表；\n* 使用 Python 实现抽象数据类型；\n* 了解基本线性数据结构的实现性能；\n* 了解前缀、中缀和后缀表达式格式，并使用堆栈进行实现和转换；\n* 使用队列进行基础时序模拟；\n* 使用 Python 实现链表结构，并进行性能比较。\n\n# 什么是线性结构\n\n---\n\n* 线性结构具有两个端点，可以称为 `左端` 和 `右端`，或者 `顶部` 和 `底部`。\n* 线性结构之间的区别主要在于添加和删除数据元素的方式。\n\n# 堆栈\n\n---\n\n## 堆栈介绍\n\n---\n\n堆栈是数据元素的有序集合，其中元素的添加和删除总是在同一端进行。这一端被称为 `顶端`。最后添加的元素最先被删除，该原则称为 `LIFO(last-in first-out)`。堆栈中的元素顺序和时间长度有关，较新的元素靠近顶端，较旧的元素靠近底端。\n\n![图1 堆栈结构](/images/primitive.png)\n\n由于堆栈后进先出的特性，非常适用于翻转元素顺序的应用场景。移除的顺序和插入的顺序相反。图2显示了创建 Python 堆栈对象时的元素顺序和移出时的元素顺序。\n\n![图2 堆栈的翻转特性](/images/simplereversal.png)\n\n\n应用场景：\n\n* 浏览器的后退功能。将访问过的 URLs 存储到一个堆栈中，当前访问的在最顶部。\n\n## 堆栈抽象数据类型\n\n---\n\n堆栈抽象数据类型由以下结构和操作定义。\n\n* 结构：堆栈是一个有序集合，数据元素在顶端进行添加和删除。\n* 操作：\n  * `Stack()`：创建一个堆栈，返回为空堆栈。\n  * `push(item)`：在堆栈顶端添加一个元素。无返回。\n  * `pop()`：移出并返回堆栈的顶端元素。\n  * `peek()`：返回堆栈的顶端元素但并不删除。\n  * `isEmpty()`：判空。返回布尔值。\n  * `size()`：返回堆栈的元素个数。整型。\n\n## 使用 Python 实现堆栈\n\n---\n\n在 Python 中，就像在任何面向对象的编程语言中一样，我们使用 `类` 来实现抽象数据类型，使用方法实现其操作。堆栈作为一个元素集合，使用 Python 中强大的 `list` 进行构造。\n\n```python\n# 使用 Python list 构造堆栈结构\nclass Stack():\n  def __init__(self):\n    self.items = []\n\n  def isEmpty(self):\n    return self.items == []\n\n  def push(self, item):\n    self.items.append(item)\n\n  def pop(self):\n    return self.items.pop()\n\n  def peek(self):\n    return self.items[len(self.items)-1]\n\n  def size(self):\n    return len(self.items)\n```\n\n## 应用：括号匹配（简单）\n\n---\n\n* 功能描述：输入一串括号，判断这些括号是否匹配。\n* 分析：从左到右读取括号串，右括号总是匹配最近一次的左括号，而最先读取的左括号可能需要等到后面。右括号匹配左括号的顺序刚好和左括号的存储顺序相反，故使用堆栈解决该问题。\n* 实现：\n  * 创建一个空堆栈，碰到左括号将其存入；\n  * 碰到右括号，取出堆栈的顶端元素进行匹配。如果匹配，则删除顶端元素，否则整个括号串不平衡。\n  * 字符串读取结束后，判断堆栈是否为空。不为空则括号串不平衡。\n\n```python\ndef parChecker(symbolString):\n  s = Stack()\n  balanced = True\n  index = 0\n  while index < len(symbolString) and balanced:\n    symbol = symbolString[i]\n    if symbol == \"(\":\n      s.push(symbol)\n    else:\n      if s.isEmpty():\n        balanced = False\n      else:\n        s.pop()\n\n    index += 1\n    \n  if balanced and s.isEmpty():\n    return True\n  else:\n    return False\n\nprint(parCheckr(\"((()))\"))\n```\n\n## 应用：括号匹配（复杂）\n\n---\n\n上一个应用中只涉及了小括号的匹配，而实际情况中，括号不光需要匹配左右对应，同时也要匹配不同的括号类型。\n\n```python\ndef parChecker(symbolString):\n  s = Stack()\n  balanced = True\n  index = 0\n  while index < len(symbolString) and balanced:\n    symbol = symbolString[i]\n    if symbol in \"([{\":\n      s.push(symbol)\n    else:\n      if s.isEmpty():\n        balanced = False\n      else:\n        top = s.pop()\n        if not matches(top, symbol):\n          balanced = False\n\n    index += 1\n  if balanced and s.isEmpty():\n    return True\n  else:\n    return False\n\ndef matches(open, close):\n  opens = \"([{\"\n  closes = \")]}\"\n  return opens.index(open) == closes.index(close)\n\nprint(parChecker('{({([][])}())}'))\nprint(parChecker('[{()]'))\n```\n\n## 应用：进制转换\n\n---\n\n使用“被2除”算法可以将十进制数转换为二进制数。“被2除”算法假定我们以大于0的整数开始，不断迭代将十进制数除以2，并保存其余数。最后将余数序列逆序极为转换后的二进制数。图3显示了该算法的过程。\n\n![图3 二进制转换](/images/dectobin.png)\n\n下面使用 Python 实现该算法。\n\n```python\ndef devideBy2(decNumber):\n  remstack = Stack()\n\n  while decNumber > 0:\n    rem = decNumber % 2\n    remstack.push(rem)\n    decNumber = decNumber // 2\n\n  binString = \"\"\n  while not remstack.isEmpty():\n    binString = binString + str(remstack.pop())\n\n  return binString\n\nprint(devideBy2(42))\n```\n\n上面的二进制转换可以很容易扩展到任意进制转换。在计算机科学中，通常使用不同的进制编码，常用的有八进制和十六进制。\n可以修改 `devideBy2` 算法，使其不仅接收十进制数，还能接收进制转换基数。下面算法实现了十进制数到2-16进制之间的转换。同时，当基数大于10后，已经不能简单地使用0-9来表示余数了。\n\n```python\ndef baseConverter(decNumber, base):\n  digits = \"0123456789ABCDEF\"\n\n  remstack = Stack()\n\n  while decNumber > 0:\n    rem = decNumber % base\n    remstack.push(rem)\n    decNumber = decNumber // base\n\n  newString = \"\"\n  while not remstack.isEmpty():\n    newString = newString + digits[remstack.pop()]\n\n  return newString\n\nprint(baseConverter(25, 2))\nprint(baseConverter(25, 16))\n```\n\n## 应用：前缀、中缀、后缀表达式\n\n---\n\n对于平常使用的表达式，如 $A+B*C$，操作符在两个操作数之间，则称为 `中缀表达式`。如果将操作符放在需要操作的两个操作数之间，如 $+A*BC$，则为 `前缀表达式`。如果将操作符放在需要操作的两个操作数之后，如 $ABC*+$，则为 `后缀表达式`。在计算机操作中，一般将中缀表达式转换为前缀或后缀表达式，原因：\n\n* 中缀表达式需要括号和操作符优先级定义计算顺序，对计算机较为复杂；\n* 前缀或后缀表达式中，操作符的位置定义了操作顺序，不需要括号和操作符的优先级，计算机实现简单。\n\n### 将中缀表达式转换为前缀或后缀表达式\n\n对于中缀表达式，我们可以通过添加括号构造完全括号表达式，即只使用括号来定义操作顺序。对于完全括号表达式，我们只需要将操作符移动到右括号处，同时删除匹配的左括号，即可实现中缀表达式到后缀表达式的转换。过程如图4所示。\n\n![图4 向右移动运算符](/images/moveright.png)\n\n同理，向左移动运算符，同时删除相匹配的右括号，即可得到前缀表达式。\n\n### 通用中缀到后缀转换\n\n对于表达式转换，操作数的位置不会发生变化，只有操作符的位置进行了移动。在后缀表达式中，原有操作符的顺序可能会根据操作优先级进行翻转。所以使用堆栈来存储操作符。\n对于有括号的表达式，遇到左括号时将其存储，在遇到右括号后，将存储的操作符取出。\n假定中缀表达式是由空格分隔的一串字符串。运算符有+、-、* 和 /，也包括左右小括号。操作数由单字符A、B、C等进行标记。将中缀转换为后缀的步骤如下：\n\n* 创建一个空的堆栈 `opstack` 保存操作符，一个空的列表保存结果。\n* 使用字符串方法 `split` 将输入字符串转换为列表。\n* 从左到右扫描整个列表：\n  * 如果是操作数，将其存储到输出列表的末尾；\n  * 如果是左括号，存储到 `opstack` 中；\n  * 如果是右括号，从 `opstack` 中取元素，直到相匹配的左括号被删除为止。把操作符依次存储到结果列表末尾；\n  * 如果是操作符，将其存储到 `opstack` 中。但是，首先需要移出任何大于或等于该操作符优先级的操作符，并将其存储到结果列表中；\n* 但输入列表扫描完毕，检查 `opstack`。任何在堆栈中的操作符都取出并添加到结果列表中。\n\n图5显示了表达式 _AB+CD_ 的转换过程。\n\n![图5 转为后缀表达式](/images/intopost.png)\n\n下面使用 Python 实现该过程。同时，使用字典 `prec` 存储操作符的优先级。左括号有最小优先级，这样所有的操作符都比左括号优先级高。\n\n```python\ndef infixToPostfix(infixexpr):\n  prec = {}\n  prec[\"*\"] = 3\n  prec[\"/\"] = 3\n  prec[\"+\"] = 2\n  prec[\"-\"] = 2\n  prec[\"(\"] = 1\n  opStack = Stack()\n  postfixList = []\n  tokenList = infixexpr.split()\n\n  for token in tokenList:\n    if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\":\n      postfixList.append(token)\n    elif token = \"(\":\n      opStack.push(token)\n    elif token = \")\":\n      topToken = opStack.pop()\n      while topToken != \"(\":\n        postfixList.append(topToken)\n        topToken = opStack.pop()\n    else:\n      while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]):\n        postfixList.append(opStack.pop())\n      opStack.push(token)\n\n  while not opStack.isEmpty():\n    postfixList.append(opStack.pop())\n  return \" \".join(postfixList)\n\nprint(infixToPostfix(\"A * B + C * D\"))\nprint(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\"))\n```\n\n### 后缀表达式计算\n\n在计算后缀表达式时，也需要使用到堆栈。但这次堆栈中应该存储操作数。每次遇到操作符，都应该从堆栈中取出两个最近的操作数进行计算，并将结果继续存储到堆栈中。\n\n![图6 计算后缀表达式4 5 6 * +](/images/evalpostfix1.png)\n\n假设后缀表达式是由空格分隔的字符串。运算符是*，/，+和 - 并且操作数假定为整数。输出是整数结果。计算后缀表达式的步骤如下：\n\n1. 创建一个空栈 `operandStack` 来存储操作数；\n2. 使用 `split` 把输入字符串转换为列表；\n3. 从左到右扫描整个列表：\n    * 如果是操作数，将其转换为整型并存储到堆栈 `operandStack` 中；\n    * 如果是操作符，则需要取出两个操作数。第一次取出的作为第二个操作数，第二次取出的作为第一个操作数。计算后将结果存储到堆栈 `operandStack` 中；\n4. 扫描完成后，取出堆栈中的值作为结果返回。\n\n下面使用 Python 实现该算法。定义一个函数 `doMath`，接收两个操作数和一个操作符，进行相应的运算。\n\n```python\ndef postfixEval(postfixExpr):\n  operandStack = Stack()\n  tokenList = postfixExpr.split()\n\n  for token in tokenList:\n    if token in \"0123456789\":\n      operandStack.push(int(token))\n    else:\n      operand2 = operandStack.pop()\n      operand1 = operandStack.pop()\n      result = doMath(token, operand1, operand2)\n      operandStack.push(result)\n\n  return operandStack.pop()\n\ndef doMath(op, op1, op2):\n  if op == \"*\":\n    return op1 * op2\n  elif op == \"/\":\n    return op1 / op2\n  elif op == \"+\":\n    return op1 + op2\n  else:\n    return op1 - op2\n\nprint(postfixEval('7 8 + 3 2 + /'))\n```\n\n上述的算法都是假定输入表达式没有错误的。\n\n# 队列\n\n---\n\n\n",[[1566309114291,["a6012@DESKTOP-FSS1ODK",[[1,19,"——"]],[19,19],[21,21]]],[1566309115270,["a6012@DESKTOP-FSS1ODK",[[-1,19,"——"]],[21,21],[19,19]]],[1566309117773,["a6012@DESKTOP-FSS1ODK",[[1,19,"_线"]],[19,19],[21,21]]]],null,"a6012@DESKTOP-FSS1ODK"]]}</div><div class="post-copyright"><blockquote><p>原文作者: lixh</p><p>原文链接: <a href="http://yoursite.com/2019/08/20/算法Python_线性数据结构.resource/commit/">http://yoursite.com/2019/08/20/算法Python_线性数据结构.resource/commit/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/20/hello-world/" class="next">Hello World</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: '797d74e1958a846713d9',
  clientSecret: '2bab30fb152aaf3d7f61a916fbe04135e950f57f',
  repo: 'Mr-lixh.github.io',
  owner: 'Mr-lixh',
  admin: ['Mr-lixh'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/算法Python_线性数据结构.resource/commit/">算法Python_线性数据结构.resource/commit</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/20/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/算法Python_线性数据结构/">算法Python_线性数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Mr-lixh" title="github" target="_blank">github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">lixh.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?13549e9998ed36aa1cfcbd1ebe61afe0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>