<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="lixh's blog"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>算法Python_线性数据结构 | lixh's blog</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">算法Python_线性数据结构</h1><a id="logo" href="/.">lixh's blog</a><p class="description">Learn and Share</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">算法Python_线性数据结构</h1><div class="post-meta"><a href="/2019/08/20/算法Python_线性数据结构/#comments" class="comment-count"></a><p><span class="date">Aug 20, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>使用python实现数据结构中的线性数据结构。</p>
<a id="more"></a>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><hr>
<ul>
<li>理解抽象数据类型，包括堆栈、队列、双端队列和列表；</li>
<li>使用 Python 实现抽象数据类型；</li>
<li>了解基本线性数据结构的实现性能；</li>
<li>了解前缀、中缀和后缀表达式格式，并使用堆栈进行实现和转换；</li>
<li>使用队列进行基础时序模拟；</li>
<li>使用 Python 实现链表结构，并进行性能比较。</li>
</ul>
<h1 id="什么是线性结构"><a href="#什么是线性结构" class="headerlink" title="什么是线性结构"></a>什么是线性结构</h1><hr>
<ul>
<li>线性结构具有两个端点，可以称为 <code>左端</code> 和 <code>右端</code>，或者 <code>顶部</code> 和 <code>底部</code>。</li>
<li>线性结构之间的区别主要在于添加和删除数据元素的方式。</li>
</ul>
<h1 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h1><hr>
<h2 id="堆栈介绍"><a href="#堆栈介绍" class="headerlink" title="堆栈介绍"></a>堆栈介绍</h2><hr>
<p>堆栈是数据元素的有序集合，其中元素的添加和删除总是在同一端进行。这一端被称为 <code>顶端</code>。最后添加的元素最先被删除，该原则称为 <code>LIFO(last-in first-out)</code>。堆栈中的元素顺序和时间长度有关，较新的元素靠近顶端，较旧的元素靠近底端。</p>
<p><img src="/images/primitive.png" alt="图1 堆栈结构"></p>
<p>由于堆栈后进先出的特性，非常适用于翻转元素顺序的应用场景。移除的顺序和插入的顺序相反。图2显示了创建 Python 堆栈对象时的元素顺序和移出时的元素顺序。</p>
<p><img src="/images/simplereversal.png" alt="图2 堆栈的翻转特性"></p>
<p>应用场景：</p>
<ul>
<li>浏览器的后退功能。将访问过的 URLs 存储到一个堆栈中，当前访问的在最顶部。</li>
</ul>
<h2 id="堆栈抽象数据类型"><a href="#堆栈抽象数据类型" class="headerlink" title="堆栈抽象数据类型"></a>堆栈抽象数据类型</h2><hr>
<p>堆栈抽象数据类型由以下结构和操作定义。</p>
<ul>
<li>结构：堆栈是一个有序集合，数据元素在顶端进行添加和删除。</li>
<li>操作：<ul>
<li><code>Stack()</code>：创建一个堆栈，返回为空堆栈。</li>
<li><code>push(item)</code>：在堆栈顶端添加一个元素。无返回。</li>
<li><code>pop()</code>：移出并返回堆栈的顶端元素。</li>
<li><code>peek()</code>：返回堆栈的顶端元素但并不删除。</li>
<li><code>isEmpty()</code>：判空。返回布尔值。</li>
<li><code>size()</code>：返回堆栈的元素个数。整型。</li>
</ul>
</li>
</ul>
<h2 id="使用-Python-实现堆栈"><a href="#使用-Python-实现堆栈" class="headerlink" title="使用 Python 实现堆栈"></a>使用 Python 实现堆栈</h2><hr>
<p>在 Python 中，就像在任何面向对象的编程语言中一样，我们使用 <code>类</code> 来实现抽象数据类型，使用方法实现其操作。堆栈作为一个元素集合，使用 Python 中强大的 <code>list</code> 进行构造。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Python list 构造堆栈结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.items = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    self.items.append(item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items[len(self.items)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure>

<h2 id="应用：括号匹配（简单）"><a href="#应用：括号匹配（简单）" class="headerlink" title="应用：括号匹配（简单）"></a>应用：括号匹配（简单）</h2><hr>
<ul>
<li>功能描述：输入一串括号，判断这些括号是否匹配。</li>
<li>分析：从左到右读取括号串，右括号总是匹配最近一次的左括号，而最先读取的左括号可能需要等到后面。右括号匹配左括号的顺序刚好和左括号的存储顺序相反，故使用堆栈解决该问题。</li>
<li>实现：<ul>
<li>创建一个空堆栈，碰到左括号将其存入；</li>
<li>碰到右括号，取出堆栈的顶端元素进行匹配。如果匹配，则删除顶端元素，否则整个括号串不平衡。</li>
<li>字符串读取结束后，判断堆栈是否为空。不为空则括号串不平衡。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(symbolString)</span>:</span></span><br><span class="line">  s = Stack()</span><br><span class="line">  balanced = <span class="literal">True</span></span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> index &lt; len(symbolString) <span class="keyword">and</span> balanced:</span><br><span class="line">    symbol = symbolString[i]</span><br><span class="line">    <span class="keyword">if</span> symbol == <span class="string">"("</span>:</span><br><span class="line">      s.push(symbol)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">        balanced = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        s.pop()</span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">print(parCheckr(<span class="string">"((()))"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="应用：括号匹配（复杂）"><a href="#应用：括号匹配（复杂）" class="headerlink" title="应用：括号匹配（复杂）"></a>应用：括号匹配（复杂）</h2><hr>
<p>上一个应用中只涉及了小括号的匹配，而实际情况中，括号不光需要匹配左右对应，同时也要匹配不同的括号类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(symbolString)</span>:</span></span><br><span class="line">  s = Stack()</span><br><span class="line">  balanced = <span class="literal">True</span></span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> index &lt; len(symbolString) <span class="keyword">and</span> balanced:</span><br><span class="line">    symbol = symbolString[i]</span><br><span class="line">    <span class="keyword">if</span> symbol <span class="keyword">in</span> <span class="string">"([&#123;"</span>:</span><br><span class="line">      s.push(symbol)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> s.isEmpty():</span><br><span class="line">        balanced = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        top = s.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matches(top, symbol):</span><br><span class="line">          balanced = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matches</span><span class="params">(open, close)</span>:</span></span><br><span class="line">  opens = <span class="string">"([&#123;"</span></span><br><span class="line">  closes = <span class="string">")]&#125;"</span></span><br><span class="line">  <span class="keyword">return</span> opens.index(open) == closes.index(close)</span><br><span class="line"></span><br><span class="line">print(parChecker(<span class="string">'&#123;(&#123;([][])&#125;())&#125;'</span>))</span><br><span class="line">print(parChecker(<span class="string">'[&#123;()]'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="应用：进制转换"><a href="#应用：进制转换" class="headerlink" title="应用：进制转换"></a>应用：进制转换</h2><hr>
<p>使用“被2除”算法可以将十进制数转换为二进制数。“被2除”算法假定我们以大于0的整数开始，不断迭代将十进制数除以2，并保存其余数。最后将余数序列逆序极为转换后的二进制数。图3显示了该算法的过程。</p>
<p><img src="/images/dectobin.png" alt="图3 二进制转换"></p>
<p>下面使用 Python 实现该算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">devideBy2</span><span class="params">(decNumber)</span>:</span></span><br><span class="line">  remstack = Stack()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> decNumber &gt; <span class="number">0</span>:</span><br><span class="line">    rem = decNumber % <span class="number">2</span></span><br><span class="line">    remstack.push(rem)</span><br><span class="line">    decNumber = decNumber // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  binString = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</span><br><span class="line">    binString = binString + str(remstack.pop())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binString</span><br><span class="line"></span><br><span class="line">print(devideBy2(<span class="number">42</span>))</span><br></pre></td></tr></table></figure>

<p>上面的二进制转换可以很容易扩展到任意进制转换。在计算机科学中，通常使用不同的进制编码，常用的有八进制和十六进制。<br>可以修改 <code>devideBy2</code> 算法，使其不仅接收十进制数，还能接收进制转换基数。下面算法实现了十进制数到2-16进制之间的转换。同时，当基数大于10后，已经不能简单地使用0-9来表示余数了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseConverter</span><span class="params">(decNumber, base)</span>:</span></span><br><span class="line">  digits = <span class="string">"0123456789ABCDEF"</span></span><br><span class="line"></span><br><span class="line">  remstack = Stack()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> decNumber &gt; <span class="number">0</span>:</span><br><span class="line">    rem = decNumber % base</span><br><span class="line">    remstack.push(rem)</span><br><span class="line">    decNumber = decNumber // base</span><br><span class="line"></span><br><span class="line">  newString = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</span><br><span class="line">    newString = newString + digits[remstack.pop()]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newString</span><br><span class="line"></span><br><span class="line">print(baseConverter(<span class="number">25</span>, <span class="number">2</span>))</span><br><span class="line">print(baseConverter(<span class="number">25</span>, <span class="number">16</span>))</span><br></pre></td></tr></table></figure>

<h2 id="应用：前缀、中缀、后缀表达式"><a href="#应用：前缀、中缀、后缀表达式" class="headerlink" title="应用：前缀、中缀、后缀表达式"></a>应用：前缀、中缀、后缀表达式</h2><hr>
<p>对于平常使用的表达式，如 $A+B<em>C$，操作符在两个操作数之间，则称为 <code>中缀表达式</code>。如果将操作符放在需要操作的两个操作数之间，如 $+A*BC$，则为 <code>前缀表达式</code>。如果将操作符放在需要操作的两个操作数之后，如 $ABC</em>+$，则为 <code>后缀表达式</code>。在计算机操作中，一般将中缀表达式转换为前缀或后缀表达式，原因：</p>
<ul>
<li>中缀表达式需要括号和操作符优先级定义计算顺序，对计算机较为复杂；</li>
<li>前缀或后缀表达式中，操作符的位置定义了操作顺序，不需要括号和操作符的优先级，计算机实现简单。</li>
</ul>
<h3 id="将中缀表达式转换为前缀或后缀表达式"><a href="#将中缀表达式转换为前缀或后缀表达式" class="headerlink" title="将中缀表达式转换为前缀或后缀表达式"></a>将中缀表达式转换为前缀或后缀表达式</h3><p>对于中缀表达式，我们可以通过添加括号构造完全括号表达式，即只使用括号来定义操作顺序。对于完全括号表达式，我们只需要将操作符移动到右括号处，同时删除匹配的左括号，即可实现中缀表达式到后缀表达式的转换。过程如图4所示。</p>
<p><img src="/images/moveright.png" alt="图4 向右移动运算符"></p>
<p>同理，向左移动运算符，同时删除相匹配的右括号，即可得到前缀表达式。</p>
<h3 id="通用中缀到后缀转换"><a href="#通用中缀到后缀转换" class="headerlink" title="通用中缀到后缀转换"></a>通用中缀到后缀转换</h3><p>对于表达式转换，操作数的位置不会发生变化，只有操作符的位置进行了移动。在后缀表达式中，原有操作符的顺序可能会根据操作优先级进行翻转。所以使用堆栈来存储操作符。<br>对于有括号的表达式，遇到左括号时将其存储，在遇到右括号后，将存储的操作符取出。<br>假定中缀表达式是由空格分隔的一串字符串。运算符有+、-、* 和 /，也包括左右小括号。操作数由单字符A、B、C等进行标记。将中缀转换为后缀的步骤如下：</p>
<ul>
<li>创建一个空的堆栈 <code>opstack</code> 保存操作符，一个空的列表保存结果。</li>
<li>使用字符串方法 <code>split</code> 将输入字符串转换为列表。</li>
<li>从左到右扫描整个列表：<ul>
<li>如果是操作数，将其存储到输出列表的末尾；</li>
<li>如果是左括号，存储到 <code>opstack</code> 中；</li>
<li>如果是右括号，从 <code>opstack</code> 中取元素，直到相匹配的左括号被删除为止。把操作符依次存储到结果列表末尾；</li>
<li>如果是操作符，将其存储到 <code>opstack</code> 中。但是，首先需要移出任何大于或等于该操作符优先级的操作符，并将其存储到结果列表中；</li>
</ul>
</li>
<li>但输入列表扫描完毕，检查 <code>opstack</code>。任何在堆栈中的操作符都取出并添加到结果列表中。</li>
</ul>
<p>图5显示了表达式 <em>AB+CD</em> 的转换过程。</p>
<p><img src="/images/intopost.png" alt="图5 转为后缀表达式"></p>
<p>下面使用 Python 实现该过程。同时，使用字典 <code>prec</code> 存储操作符的优先级。左括号有最小优先级，这样所有的操作符都比左括号优先级高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></span><br><span class="line">  prec = &#123;&#125;</span><br><span class="line">  prec[<span class="string">"*"</span>] = <span class="number">3</span></span><br><span class="line">  prec[<span class="string">"/"</span>] = <span class="number">3</span></span><br><span class="line">  prec[<span class="string">"+"</span>] = <span class="number">2</span></span><br><span class="line">  prec[<span class="string">"-"</span>] = <span class="number">2</span></span><br><span class="line">  prec[<span class="string">"("</span>] = <span class="number">1</span></span><br><span class="line">  opStack = Stack()</span><br><span class="line">  postfixList = []</span><br><span class="line">  tokenList = infixexpr.split()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">    <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</span><br><span class="line">      postfixList.append(token)</span><br><span class="line">    <span class="keyword">elif</span> token = <span class="string">"("</span>:</span><br><span class="line">      opStack.push(token)</span><br><span class="line">    <span class="keyword">elif</span> token = <span class="string">")"</span>:</span><br><span class="line">      topToken = opStack.pop()</span><br><span class="line">      <span class="keyword">while</span> topToken != <span class="string">"("</span>:</span><br><span class="line">        postfixList.append(topToken)</span><br><span class="line">        topToken = opStack.pop()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> (prec[opStack.peek()] &gt;= prec[token]):</span><br><span class="line">        postfixList.append(opStack.pop())</span><br><span class="line">      opStack.push(token)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</span><br><span class="line">    postfixList.append(opStack.pop())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">" "</span>.join(postfixList)</span><br></pre></td></tr></table></figure>

<h3 id="后缀表达式计算"><a href="#后缀表达式计算" class="headerlink" title="后缀表达式计算"></a>后缀表达式计算</h3><p>在计算后缀表达式时，也需要使用到堆栈。但这次堆栈中应该存储操作数。每次遇到操作符，都应该从堆栈中取出两个最近的操作数进行计算，并将结果继续存储到堆栈中。</p>
<p><img src="/images/evalpostfix1.png" alt="图6 计算后缀表达式4 5 6 * +"></p>
<p>假设后缀表达式是由空格分隔的字符串。运算符是*，/，+和 - 并且操作数假定为整数。输出是整数结果。计算后缀表达式的步骤如下：</p>
<ol>
<li>创建一个空栈 <code>operandStack</code> 来存储操作数；</li>
<li>使用 <code>split</code> 把输入字符串转换为列表；</li>
<li>从左到右扫描整个列表：<ul>
<li>如果是操作数，将其转换为整型并存储到堆栈 <code>operandStack</code> 中；</li>
<li>如果是操作符，则需要取出两个操作数。第一次取出的作为第二个操作数，第二次取出的作为第一个操作数。计算后将结果存储到堆栈 <code>operandStack</code> 中；</li>
</ul>
</li>
<li>扫描完成后，取出堆栈中的值作为结果返回。</li>
</ol>
<p>下面使用 Python 实现该算法。定义一个函数 <code>doMath</code>，接收两个操作数和一个操作符，进行相应的运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postfixEval</span><span class="params">(postfixExpr)</span>:</span></span><br><span class="line">  operandStack = Stack()</span><br><span class="line">  tokenList = postfixExpr.split()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</span><br><span class="line">    <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</span><br><span class="line">      operandStack.push(int(token))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      operand2 = operandStack.pop()</span><br><span class="line">      operand1 = operandStack.pop()</span><br><span class="line">      result = doMath(token, operand1, operand2)</span><br><span class="line">      operandStack.push(result)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> operandStack.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doMath</span><span class="params">(op, op1, op2)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> op == <span class="string">"*"</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 * op2</span><br><span class="line">  <span class="keyword">elif</span> op == <span class="string">"/"</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 / op2</span><br><span class="line">  <span class="keyword">elif</span> op == <span class="string">"+"</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 + op2</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> op1 - op2</span><br><span class="line"></span><br><span class="line">print(postfixEval(<span class="string">'7 8 + 3 2 + /'</span>))</span><br></pre></td></tr></table></figure>

<p>上述的算法都是假定输入表达式没有错误的。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><hr>
<h2 id="队列简介"><a href="#队列简介" class="headerlink" title="队列简介"></a>队列简介</h2><hr>
<ul>
<li>队列是一个有序集合；</li>
<li>数据元素从后端（rear）插入，从前端（front）移出；</li>
<li>前端元素在队列中的时间最长；</li>
<li>这种插入删除的顺序成为先入先出（FIFO, first-in first-out）。</li>
</ul>
<p>图1显示了一个简单的 Python 数据对象——队列。</p>
<p><img src="/images/basicqueue.png" alt="图1 队列"></p>
<p>常见示例：</p>
<ul>
<li>打印队列；</li>
<li>计算机进程；</li>
<li>键盘输入等。</li>
</ul>
<h2 id="队列抽象数据类型"><a href="#队列抽象数据类型" class="headerlink" title="队列抽象数据类型"></a>队列抽象数据类型</h2><hr>
<p>队列的结构如上节所讲，队列的操作主要如下：</p>
<ul>
<li><code>Queue()</code>：创建一个空队列并返回；</li>
<li><code>enqueue(item)</code>：添加一个新元素到队列尾部；</li>
<li><code>dequeue()</code>：移出队列前端元素并返回；</li>
<li><code>isEmpty()</code>：判断队列是否为空。返回布尔值；</li>
<li><code>size()</code>：返回队列中的元素个数。</li>
</ul>
<h2 id="使用-Python-实现队列"><a href="#使用-Python-实现队列" class="headerlink" title="使用 Python 实现队列"></a>使用 Python 实现队列</h2><hr>
<p>和堆栈一样，我们使用 Python 中的 <code>list</code> 来实现队列类。下面代码假定列表的 0 位置处为队列的尾端，可以使用 <code>insert</code> 方法插入元素。使用 <code>pop</code> 方法删除列表的前端元素。这样，入队的时间复杂度为 <code>O(n)</code>，出队的时间复杂度为 <code>O(1)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.items = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure>

<h2 id="模拟：Hot-Potato"><a href="#模拟：Hot-Potato" class="headerlink" title="模拟：Hot Potato"></a>模拟：Hot Potato</h2><hr>
<p>显示队列运行的经典方式就是模拟需要以 FIFO 方式管理数据的实际情景。比如，游戏“Hot Potato”。如图2所示，孩子们围成一个圆圈，然后一个挨一个的传递热土豆。在某一时刻，动作停止，持有土豆的孩子从圈中移出。游戏继续直到只剩一个孩子。</p>
<p><img src="/images/hotpotato.png" alt="hotpotato"></p>
<p>我们使用程序来对这个游戏进行模拟。程序会输入一个名称列表以及一个常数 <code>num</code>，用来计数并淘汰成员。为了模拟该圆圈，我们可以使用一个队列（见图3）。假设拿着热土豆的孩子在队列的前端，传递土豆后，进行出队并继续入队，即可实现循环。当达到 <code>num</code> 值后，队列前端的元素被永久删除。循环继续，直到队列中只剩一个元素。</p>
<p><img src="/images/namequeue.png" alt="namequeue"></p>
<p>下面使用代码实现该模拟。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hotPotato</span><span class="params">(nameList, num)</span>:</span></span><br><span class="line">  simqueue = Queue()</span><br><span class="line">  <span class="keyword">for</span> name <span class="keyword">in</span> nameList:</span><br><span class="line">    simqueue.enqueue(name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> simqueue.size() &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">      simqueue.enqueue(simqueue.dequeue())</span><br><span class="line"></span><br><span class="line">    simqueue.dequeue()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> simqueue.dequeue()</span><br><span class="line"></span><br><span class="line">print(hotPotato([<span class="string">"Bill"</span>, <span class="string">"David"</span>, <span class="string">"Susan"</span>, <span class="string">"Jane"</span>, <span class="string">"Kent"</span>], <span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<h2 id="模拟：打印序列"><a href="#模拟：打印序列" class="headerlink" title="模拟：打印序列"></a>模拟：打印序列</h2><hr>
<p>当学生将打印任务发送到共享打印机时，任务被放入打印队列中，以先到先得的方式进行处理。我们需要为学生、打印任务和打印机构建表示（图4）。当学生提交打印任务时，将它们添加到等待队列中，这是一个连接到打印机的打印任务队列。当打印机完成任务时，它将查看队列是否还有任何要处理的剩余任务。我们感兴趣的是学生等待他们的论文打印的平均时间。这等于任务在队列中等待的平均时间。</p>
<p><img src="images/simulationsetup.png" alt="simulationsetup"></p>
<p>为了模拟这种情况，我们需要使用概率。例如，学生可以打印长度为1到20页的纸张。如果每个长度从1到20的可能性相同，则可以使用1到20之间的随机数来模拟打印任务的实际长度。这意味着出现1至20的任何长度的机会均等。如果实验室中有10名学生，每人打印两次，则平均每小时有20个打印任务，每个任务平均180秒。<br>对于每一秒，我们可以通过生成1到180之间的随机数来模拟打印任务发生的可能性。如果数字是180，我们说已经创建了一个任务。可能会连续创建许多任务，也可能需要等待很长时间才会有一个任务。</p>
<h3 id="主要模拟步骤"><a href="#主要模拟步骤" class="headerlink" title="主要模拟步骤"></a>主要模拟步骤</h3><ol>
<li>创建一个空的打印队列。每项任务在到达时都会给出一个时间戳；</li>
<li>对于每一秒（<code>currentSecond</code>）：<ul>
<li>是否创建了新的打印任务？如果是，则将 <code>currentSecong</code> 作为时间戳并且送入任务队列中；</li>
<li>如果打印机不忙并且有任务正在等待：<ul>
<li>从打印队列中移除下一个任务并送入打印机；</li>
<li>从 <code>currentSecond</code> 中减去任务的时间戳以计算该任务的等待时间；</li>
<li>将该任务的等待时间添加到列表中以便后续计算；</li>
<li>根据打印任务中的页数，计算出需要打印的时长；</li>
</ul>
</li>
<li>打印机现在可以进行一秒钟的打印，并从该任务所需的时间减去一秒。</li>
<li>如果任务已完成，即所需时间为 0，则打印机不再忙碌。</li>
</ul>
</li>
<li>模拟结束后，根据生成的等待时间列表计算平均等待时间。</li>
</ol>
<h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><p>对于该模拟，我们将创建三个类来表示这三个物体：<code>Printer</code>、<code>Task</code> 和 <code>PrintQueue</code>。<br><code>Printer</code> 类需要跟踪当前是否在执行任务。如果是，则为忙碌状态。并且根据当前任务的页数来计算打印时间。构造对象时可以设定打印机每分钟打印的页数。<code>tick</code> 方法会递减内部计时器，如果任务完成则打印机为空闲状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ppm)</span>:</span></span><br><span class="line">    self.pagerate = ppm</span><br><span class="line">    self.currentTask = <span class="literal">None</span></span><br><span class="line">    self.timeRemaining = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tick</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.currentTask != <span class="literal">None</span>:</span><br><span class="line">      self.timeRemaining -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> self.timeRemaining &lt;= <span class="number">0</span>:</span><br><span class="line">        self.currentTask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">busy</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.currentTask != <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startNext</span><span class="params">(self, newtask)</span>:</span></span><br><span class="line">    self.currentTask = newtask</span><br><span class="line">    self.timeRemaining = newtask.getPage() * <span class="number">60</span>/self.pagerate</span><br></pre></td></tr></table></figure>

<p><code>Task</code> 类表示一个打印任务。创建任务时，随机数生成器将随机提供一个页面长度（1-20）。我们使用 <code>random</code> 库中的 <code>randrange</code> 函数生成页面长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.randrange(<span class="number">1</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p>每个任务都需要一个时间戳属性来计算等待时间。此时间戳表示创建该任务并送入打印队列的时间点。<code>waitTime</code> 方法可以计算该任务在打印队列中等待的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, time)</span>:</span></span><br><span class="line">    self.timestamp = time</span><br><span class="line">    self.pages = random.randrange(<span class="number">1</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getStamp</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.timestamp</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPages</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.pages</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">waitTime</span><span class="params">(self, currentTime)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> currentTime - self.timestamp</span><br></pre></td></tr></table></figure>

<p>主函数 <code>simulation</code> 实现了上述算法。<code>printQueue</code> 对象是现有队列的一个实例。布尔型辅助函数 <code>newPrintTask</code> 用于决定是否已经创建了新的打印任务。再次使用随机函数来模拟生成打印任务。该模拟功能可以设置打印机的总时长和每分钟打印的页数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulation</span><span class="params">(numSeconds, pagesPerMinute)</span>:</span></span><br><span class="line"></span><br><span class="line">  labprinter = Printer(pagesPerMinute)</span><br><span class="line">  printQueue = Queue()</span><br><span class="line">  waitingtimes = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> currentSecond <span class="keyword">in</span> range(numSeconds):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> newPrintTask():</span><br><span class="line">      task = Task(currentSecond)</span><br><span class="line">      printQueue.enqueue(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> labprinter.busy()) <span class="keyword">and</span> (<span class="keyword">not</span> printQueue.isEmpty()):</span><br><span class="line">      nexttask = printQueue.dequeue()</span><br><span class="line">      waitingtimes.append(nexttask.waitTime(currentSecond))</span><br><span class="line">      labprinter.startNext(nexttask)</span><br><span class="line"></span><br><span class="line">    labprinter.tick()</span><br><span class="line"></span><br><span class="line">  averageWait = sum(waitingtimes) / len(waitingtimes)</span><br><span class="line">  print(<span class="string">"Average wait %6.2f secs %3d tasks remaining."</span>%(averageWait, printQueue.size()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newPrintTask</span><span class="params">()</span>:</span></span><br><span class="line">  num = random.randrange(<span class="number">1</span>, <span class="number">181</span>)</span><br><span class="line">  <span class="keyword">if</span> num == <span class="number">180</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">  simulation(<span class="number">3600</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><hr>
<p><code>Deque</code> 也称为双端队列，是一种类似于队列的抽象数据结构。所不同的是，双端队列的添加和删除没有限制。即，可以在任何一端进行添加，也可以在任何一端进行删除操作。从某种意义上说，这种混合线性结构提供了堆栈和队列的所有功能。下图显示了 Python 中的双端队列数据对象。</p>
<p><img src="/images/basicdeque.png" alt="basicdeque"></p>
<h2 id="双端队列抽象数据类型"><a href="#双端队列抽象数据类型" class="headerlink" title="双端队列抽象数据类型"></a>双端队列抽象数据类型</h2><hr>
<p>双端队列的数据结构如上节所示，其操作主要如下：</p>
<ul>
<li><code>Deque()</code>：创建一个空的双端队列；</li>
<li><code>addFront(item)</code>：在双端队列的前端添加一个数据元素；</li>
<li><code>addRear(item)</code>：在双端队列的尾部添加一个数据元素；</li>
<li><code>removeFront()</code>：移除并返回双端队列的前端元素；</li>
<li><code>removeRear()</code>：移除并返回双端队列的尾部元素；</li>
<li><code>isEmpty()</code>：判断队列是否为空。返回布尔值；</li>
<li><code>size()</code>：返回双端队列的长度。</li>
</ul>
<h2 id="使用-Python-实现双端队列"><a href="#使用-Python-实现双端队列" class="headerlink" title="使用 Python 实现双端队列"></a>使用 Python 实现双端队列</h2><hr>
<p>下面使用 Python 中的 <code>list</code> 实现双端队列。假定索引为 0 的位置为队列的尾部。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.items = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addFront</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    self.items.append(item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addRear</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    self.items.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeFront</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">removeRear</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.items)</span><br></pre></td></tr></table></figure>

<h2 id="应用：回文检查"><a href="#应用：回文检查" class="headerlink" title="应用：回文检查"></a>应用：回文检查</h2><hr>
<p>使用双端队列可以轻松解决的一个经典问题就是回文检查。回文（palindrome）指的是从前和从后读取一个字符串，其值一样，如 <em>ragar<em>、</em>toot</em> 和 <em>madam</em> 等。可以使用双端队列存储该字符串。然后从两端同时移出元素并进行比较。</p>
<p><img src="/images/palindromesetup.png" alt="palindromesetup"></p>
<p>下面使用代码实现该功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palchecker</span><span class="params">(aString)</span>:</span></span><br><span class="line">  chardeque = Deque()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ch <span class="keyword">in</span> aString:</span><br><span class="line">    chardeque.addRear(ch)</span><br><span class="line"></span><br><span class="line">  stillEqual = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> chardeque.size() &gt; <span class="number">1</span> <span class="keyword">and</span> stillEqual:</span><br><span class="line">    first = chardeque.removeFront()</span><br><span class="line">    last = chardeque.removeRear()</span><br><span class="line">    <span class="keyword">if</span> first != last:</span><br><span class="line">      stillEqual = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stillEqual</span><br><span class="line"></span><br><span class="line">print(palchecker(<span class="string">"ladfgfdal"</span>))</span><br></pre></td></tr></table></figure>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><hr>
<p>在整个线性数据结构中，我们使用 Python 中的 <code>list</code> 来构造各种抽象数据类型。但是，并非所有的编程语言都包含列表集合。所以在这些情况下，列表的概念需要单独实现。<br>列表是元素的集合，其中每个元素相对于其他数据元素保持相对位置。更具体的，我们可以成这种类型的列表为无序列表。为简单起见，假定列表中不能包含重复项。</p>
<h2 id="无序列表抽象数据类型"><a href="#无序列表抽象数据类型" class="headerlink" title="无序列表抽象数据类型"></a>无序列表抽象数据类型</h2><hr>
<p>下面定义了一些无序列表的操作：</p>
<ul>
<li><code>List()</code>：创建并返回一个空的列表；</li>
<li><code>add(item)</code>：向列表中添加一个数据元素。假定不重复；</li>
<li><code>remove(item)</code>：从列表中移除数据项 <code>item</code>。假定数据项存在；</li>
<li><code>search(item)</code>：查找 <code>item</code> 是否存在。返回布尔值；</li>
<li><code>isEmpty()</code>：判断列表是否为空，返回布尔值；</li>
<li><code>size()</code>：返回列表的长度；</li>
<li><code>append(item)</code>：将 <code>item</code> 添加到列表末尾，使其成为列表集合中的最后一项。假定不重复；</li>
<li><code>index(item)</code>：返回 <code>item</code> 在列表中的索引，返回值整型，假定存在；</li>
<li><code>insert(pos, item)</code>：在列表的 <code>pos</code> 位置处添加一个新的数据项 <code>item</code>。假定存在该位置；</li>
<li><code>pop()</code>：移除并返回列表的最后一项。假定列表不为空；</li>
<li><code>pop(pos)</code>：移除并返回位置 <code>pos</code> 处的数据项。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><hr>
<p>为了实现无序列表，我们需要构造一个链表。如上节所示，我们需要保持列表中数据项的相对位置，同时，并不要求这些数据项存储在连续的内存中。我们可以在每一个数据项中保留一个位置信息，该信息指向下一个数据项的位置。那么，整个列表的位置可以通过简单地跟随从一个数据项到下一个数据项的链接来表示。<br>对于链表，我们需要明确指定第一个数据项的位置。链表的外部引用通常称为链表的 <code>head</code>，同时，链表的最后一项也需要知道没有下一个数据项了。</p>
<h3 id="Node-类"><a href="#Node-类" class="headerlink" title="Node 类"></a>Node 类</h3><p>链表的基本单元是节点。每个节点对象必须包含两条信息。首先，每个节点必须包含数据项本身，即数据段（data field）。此外，每个节点也要包含对下一个节点的引用信息。<br>下面使用 Python 实现 Node 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initdata)</span>:</span></span><br><span class="line">    self.data = initdata</span><br><span class="line">    self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.next</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setData</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">    self.data = newdata</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self, newnext)</span>:</span></span><br><span class="line">    self.next = newnext</span><br></pre></td></tr></table></figure>

<p>其中引用值为 <code>None</code> 表示没有下一个节点。明确的将 <code>None</code> 分配给初始化节点的引用值是一个好的习惯。下图表示创建一个节点对象 <code>temp</code>。</p>
<p><img src="/images/node.png" alt="node"></p>
<h3 id="Unordered-List-类"><a href="#Unordered-List-类" class="headerlink" title="Unordered List 类"></a>Unordered List 类</h3><p>如上所述，无序列表是由一组节点构成，每个节点通过显示引用指向下一个节点。<code>UnorderedList</code> 类必须持有对第一个节点的引用。即，每个列表对象将保持对列表头部节点的单个引用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnorderedList</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.head == <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>下图表示了由列表类创建的一个列表。列表的头部指向第一个节点的位置。</p>
<blockquote>
<p><strong>注意</strong>：列表类本身不包含任何节点对象。相反，它只包含对链接结构中第一个节点的单个引用。</p>
</blockquote>
<p><img src="/images/linkedlist.png" alt="linkedlist"></p>
<p>对于链表中的 <code>add</code> 方法，添加新节点最简单的位置就是链表的头部。所以，我们将新数据项作为列表的第一项，同时将现有数据项链接到这个新的数据项。<br>下面实现 <code>add</code> 方法。下图显示了插入新节点的两个步骤。这两个步骤的顺序非常重要。如果颠倒，则会丢失所有原始节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">  temp = Node(item)</span><br><span class="line">  temp.setNext(self.head)</span><br><span class="line">  self.head = temp</span><br></pre></td></tr></table></figure>

<p><img src="/images/addtohead.png" alt="Adding a New Node is a Two-Step Process"></p>
<p>下面实现链表的 <code>size</code>、<code>search</code> 和 <code>remove</code> 方法，这些方法都是基于链表遍历技术实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># size方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">  current = self.head</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  whilt current != <span class="literal">None</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    current = current.getNext()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p><img src="/images/traversal.png" alt="Traversing the Linked List from the Head to the End"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">  current = self.head</span><br><span class="line">  found = <span class="literal">False</span></span><br><span class="line">  <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">    <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">      found = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      current = current.getNext()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<p>例如，使用 <code>search</code> 方法查找数据项 17。过程如下图所示。</p>
<p><img src="/images/search.png" alt="Successful Search for the Value 17"></p>
<p><code>remove</code> 方法的实现需要两个步骤。首先，需要遍历整个链表找到要删除的元素。找到后（假定存在）将其移除。当 <code>found</code> 标识为 <code>True</code> 则表示 <code>current</code> 所指的即为要删除的元素。要删除该节点，我们需要修改前一节点中的链接，以便它指向当前节点后的节点。但是，对于单链表，不能倒退。解决办法就是使用两个指针。<code>current</code> 指向当前节点，<code>previous</code> 指向上一个节点。<br>下面使用 Python 实现该方法。当找到该项后，<code>found</code> 设为 <code>True</code>，否则 <code>previous</code> 和 <code>current</code> 都向前移动一个位置。这两个指针的移动顺序非常重要，必须先移动 <code>previous</code>，再移动 <code>current</code>。下图展示了删除数据 17 的具体步骤。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">  current = self.head</span><br><span class="line">  previous = <span class="literal">None</span></span><br><span class="line">  found = <span class="literal">False</span></span><br><span class="line">  whie <span class="keyword">not</span> found:</span><br><span class="line">    <span class="keyword">if</span> current.getData == item:</span><br><span class="line">      found = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      previous = current</span><br><span class="line">      current = current.getNext()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> previous == <span class="literal">None</span>:</span><br><span class="line">    self.head = current.getNext()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    previous.setNext(current.getNext())</span><br></pre></td></tr></table></figure>

<p><img src="/images/prevcurr.png" alt="`previous` and `current` Move Down the List"></p>
<p>在上面代码中，对于删除 <code>current</code> 节点，有一个特殊情况需要进行判别。如果要删除的数据项恰好是第一项，则 <code>previous</code> 的值依旧是 <code>None</code>。此时需要修改列表 <code>head</code> 的值。</p>
<p><img src="/images/remove2.png" alt="Removing the First Node from the List"></p>
<h2 id="有序列表抽象数据类型"><a href="#有序列表抽象数据类型" class="headerlink" title="有序列表抽象数据类型"></a>有序列表抽象数据类型</h2><hr>
<p>有序列表是一个数据项的有序集合，其中数据项根据某些特征进行了排序（升序或降序）。有序列表的许多操作与 无序列表相同。</p>
<ul>
<li><code>OrderedList()</code>：创建一个空的有序列表并返回；</li>
<li><code>add(item)</code> 、<code>pop()</code>等其他方法。</li>
</ul>
<h2 id="使用-Python-实现有序列表"><a href="#使用-Python-实现有序列表" class="headerlink" title="使用 Python 实现有序列表"></a>使用 Python 实现有序列表</h2><hr>
<p>有序列表中的数据项必须按照某一特征进行排好序。例如有序整数列表（17，26，31，54，77，93），使用链表结构进行表示（下图）。</p>
<p><img src="/images/orderlinkedlist.png" alt="An Ordered Linked List"></p>
<p>使用 Python 定义 <code>OrderedList</code> 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>对于有序列表的 <code>isEmpty</code> 和  <code>size</code> 方法，可以与无序列表一样实现，因为它们只处理了列表中的节点数而不考虑实际的数据值。同样，<code>remove</code> 也可以一样工作。而对于方法 <code>search</code> 和 <code>add</code>，我们需要进行一些修改。<br>对于 <code>search</code> 方法，当没有找到数据项时，可以利用排序特征提前结束搜索。<br>如下图，在一个有序链表中搜索 45。当搜索到 54 时就可以结束搜索了。</p>
<p><img src="/images/orderedsearch.png" alt="Searching an Ordered Linked List"></p>
<p>下面使用 Python 实现该方法。同时使用 <code>stop</code> 标识来标记是检索到了比 <code>item</code> 大的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">  current = self.head</span><br><span class="line">  found = <span class="literal">False</span></span><br><span class="line">  stop = <span class="literal">False</span></span><br><span class="line">  <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">    <span class="keyword">if</span> current.getData() == item:</span><br><span class="line">      found = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">        stop = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        current = current.getNext()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<p>最重要的是 <code>add</code> 方法。对于无序列表，我们可以简单地将新元素添加到链表头部。但对于有序链表，需要找到 <code>item</code> 的特定位置后在进行插入。<br>假设有一个有序列表（17，26，31，54，77，93），下图展示了插入 31 的过程。</p>
<p><img src="images/linkedlistinsert.png" alt="Adding an Item to an Ordered Linked List"></p>
<p>下面使用 Python 实现上述过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">  current = self.head</span><br><span class="line">  previous = <span class="literal">None</span></span><br><span class="line">  stop = <span class="literal">False</span></span><br><span class="line">  <span class="keyword">while</span> current != <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</span><br><span class="line">    <span class="keyword">if</span> current.getData() &gt; item:</span><br><span class="line">      stop = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      previous = current</span><br><span class="line">      current = current.getNext()</span><br><span class="line"></span><br><span class="line">  temp = Node(item)</span><br><span class="line">  <span class="keyword">if</span> previous == <span class="literal">None</span>:</span><br><span class="line">    temp.setNext(self.head)</span><br><span class="line">    self.head = temp</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    temp.setNext(current)</span><br><span class="line">    previous.setNext(temp)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<ul>
<li>线性数据结构以有序的方式存储数据；</li>
<li>堆栈是一种 LIFO 的数据结构，队列是一种 FIFO 的数据结构；</li>
<li>列表中的数据元素都有相对位置；</li>
<li>链表不需要物理存储顺序连续，使用指针保持元素的逻辑顺序。</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: lixh</p><p>原文链接: <a href="http://yoursite.com/2019/08/20/算法Python_线性数据结构/">http://yoursite.com/2019/08/20/算法Python_线性数据结构/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/22/算法Python_排序和搜索/" class="pre">算法Python_排序与搜索</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: '797d74e1958a846713d9',
  clientSecret: '2bab30fb152aaf3d7f61a916fbe04135e950f57f',
  repo: 'Mr-lixh.github.io',
  owner: 'Mr-lixh',
  admin: ['Mr-lixh'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#目标"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是线性结构"><span class="toc-text">什么是线性结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#堆栈"><span class="toc-text">堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#堆栈介绍"><span class="toc-text">堆栈介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆栈抽象数据类型"><span class="toc-text">堆栈抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Python-实现堆栈"><span class="toc-text">使用 Python 实现堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：括号匹配（简单）"><span class="toc-text">应用：括号匹配（简单）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：括号匹配（复杂）"><span class="toc-text">应用：括号匹配（复杂）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：进制转换"><span class="toc-text">应用：进制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：前缀、中缀、后缀表达式"><span class="toc-text">应用：前缀、中缀、后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将中缀表达式转换为前缀或后缀表达式"><span class="toc-text">将中缀表达式转换为前缀或后缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通用中缀到后缀转换"><span class="toc-text">通用中缀到后缀转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后缀表达式计算"><span class="toc-text">后缀表达式计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#队列"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#队列简介"><span class="toc-text">队列简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列抽象数据类型"><span class="toc-text">队列抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Python-实现队列"><span class="toc-text">使用 Python 实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟：Hot-Potato"><span class="toc-text">模拟：Hot Potato</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟：打印序列"><span class="toc-text">模拟：打印序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要模拟步骤"><span class="toc-text">主要模拟步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-实现"><span class="toc-text">Python 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双端队列"><span class="toc-text">双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双端队列抽象数据类型"><span class="toc-text">双端队列抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Python-实现双端队列"><span class="toc-text">使用 Python 实现双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用：回文检查"><span class="toc-text">应用：回文检查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#列表"><span class="toc-text">列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#无序列表抽象数据类型"><span class="toc-text">无序列表抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-类"><span class="toc-text">Node 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unordered-List-类"><span class="toc-text">Unordered List 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有序列表抽象数据类型"><span class="toc-text">有序列表抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Python-实现有序列表"><span class="toc-text">使用 Python 实现有序列表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/24/Docker的一些整理/">Docker的一些整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/22/Python数据分析6_模型评估/">Python数据分析6_模型评估</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/22/Python数据分析5_数据建模/">Python数据分析5_数据建模</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/22/Python数据分析4_数据预处理/">Python数据分析4_数据预处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/Python数据分析3_多因子探索分析/">Python数据分析3_多因子探索分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/Python数据分析2_单因子探索分析/">Python数据分析2_单因子探索分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/21/Python数据分析1_数据获取/">Python数据分析1_数据获取</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/Python数据分析_基础技术篇/">Python数据分析_基础技术篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/OnlineJudge项目总结/">OnlineJudge项目总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/MySQL面试指南_笔记二/">MySQL面试指南_笔记二</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/开发/" style="font-size: 15px;">开发</a> <a href="/tags/数据分析/" style="font-size: 15px;">数据分析</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/虚拟化/" style="font-size: 15px;">虚拟化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/Mr-lixh" title="github" target="_blank">github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">lixh.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?13549e9998ed36aa1cfcbd1ebe61afe0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>